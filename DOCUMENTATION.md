# CENTRAL GLOSSARY OF APPLICATON

## Custom Middleware Local Authentication: isAuth()

ADD MIDDLEWARES INTO ROUTE HANDLER AS ARGUMENT.
Check if the current User is logged in. LogIn status by express-session middleware.

ADD as many Arguments/ Middleware we want => Parsed from the left to right (request)
So if the User is logged in => next() middleware => getAddProduct

If User is not logged in => return res.redirect(); No 'next' middleware

The **args** WILL be propably inserted into an array with the help of the ...rest operator

## Custom Middleware Global Session: haveActiveSession()

CHECK IF CURRENT USER HAS AN ACTIVE SESSIOIN:
if so:

*req.user* will survive cross request because the userId is stored in the sessionStore
it will have session data loaded / if no session was found session object by default

req.user : req object property
NEED mongoose model methods to work with the document
STORE THAT USER IN REQUEST to use it anywhere in app

else:

call next() middleware function (Route Filter)

---

## Regular Middleware Global Configuration: template/ view engine (ejs)

About the *args*:
reserved keys --> views (dir to dynamic views - default = /views) & views engine -> tell express for any dynnmaic templates trying to render;

req.render() => a special function will be there to render the template file and
transform it to an actual html file and send it back to the browser as response

Initialization:

app.set("view engine" : String, "ejs" : String);
app.set("views" : String, "views" : String)

app.get(key, value) = access global set variables

## Regular Middleware Local Authentication: express-session

Initialization:

app.use(session({secret, resave, saveUninitialized, store}))
SESSION CONFIGRUATION - ARGS

1. secret: used for signing the HASH which secretly stores our ID in the cookie / key for encrypting cookies

2. resafe: session will not be saved on every request that is done, so on every response that is sent but only if something changed in the session => improve perfomance

3. saveUnitialized: no session gets saved for a request where it doesn't need to be saved because nothing was changed about it

4. cookie: configuration for session cookie like Max-Age; Http-Only; Expires

Advantage: each request brings a cookie => this cookie identifies a session (parsed by session middleware) => collectionData in req.session thus: now the user is available for every (accross) request object from the same window / tab -> which identifies a particular session by the session id

## Regular Middleware Global Csrf Protection: csurf

Initialization after session middleware:
Generally enabled
app.use(csrf())
**Args:**

1. secret: Used for assigning token / hashing
2. cookie: Boolean = store secret in cookie or in session store (default)

return value: Middleware
It provides req.csrfToken() method to generate a random csrf token;

***Note*** => Use app.use => res.locals.[var] to set lcoal variables for the fields of the views.

## Regular Middleware Global Configuration: connect-flash

For storing short-lived message in the user session: Ensure it is available after redirection
Initialization: After session / after csurf initialization

app.use(flash());

Usage:
Only key = get
both key & value = set
req.flash("key", "message")

---

## Explain Authentication: User reset password

User will enter his email into a form, and we send a email to him
with a unqiue token. With this unique token which is stored in the database,
he is allowed to reset his password

***Purpose*** Verify he can only reset THROUGH US/ WITH OUR PERMISSION.

## Explain CSRF token (ONLY FOR REQUESTS THAT MUTATE STATE (such as post))

*Prequisites*: Either a express-session or cookie-parser (cookie option => true)

1. For each session a csrf secret (to hash token) is saved in the session store
2. each view got a csrf token in the hidden input field / query string

Now user makes an post requeset: login:
***csurf*** middleware fetch the token scret from either the session or cookie, then verify it is a valid token **generated by the secret** owned by the user.

## Regular Middleware Local Input-Validation: express-validation: /check

***Package:***

const { check, body } = require("express-validator/check");

***Errors*** Object:
! REQ.ERRORS OBJECT MANAGED BY THE MIDDLEWARE
go through the request object and collect them all in this error constant
return an array of objects

result: [{location: "body", param: 'email = failed validation field', "value": 'test', msg: "Invalid Value"}]

Special methods: isEmpty(); array();

const { validationResult } = require("express-validator/check");

Extracts the validation errors for the specified fields ((like isEmail()) for the specified fields.) from a request and makes them available in a Result Object

const errors = validationResult(req)
In order to read convert to errors.array() || isEmtpy() ?

1. check() for all locations => .validator
req.body, req.cookies, req.headers, req.params, req.query
To only check for specific field locations: body, cookie, header, param, query([fields, message])

2. field => a string or an array of strings of field names to validate against
3. message: an error message to use when failed validators dont't specify a message
returns a Validation chain (middleware) for one or more fields

4. isEmail() => validator addded to the Validation chain

5. withMessage() => will refer to the prior middleware; Customize the error Message

## Regular Middleware Global ParsingFiles: Multer

Multer will look for Form submits in every incoming request where enctype is set to "mutlipart/formdata" and it will try to parse it for us.

**Initialization**
Extract in request one single file from the req.body where name equals image
app.use(multer().single("image"));

It will save the extracted file in the request object as file

***Output***:
{fieldname: "image", originalname: "fileName", encoding: "7bit", mimetype, buffer (binary data)}

***Configuration***
dest: Where to save the input Files


## Regular Package Local generate PDF files: pdfkit

Allows to generate pdf on fly on the server.
Very powerful package with fontSize ....
